    以R中的sub函数为例（因为该函数可以返回替换字符串后的具体内容）介绍正则表达式的用法。

　　对该函数的逻辑参数都使用默认值（ignore.case = FALSE，表示大小写敏感；extended = TRUE，表示使用egrep规则；perl = FALSE，表示不使用Perl规则；fixed = FALSE，表示不使用精确匹配；useBytes = FALSE，表示按字符匹配）。另外三个中，pattern为字符串表示正则表达式，replacement也是字符串表示替换的内容，x为字符型向量表示被替换的字符向量。该函数会根据pattern的规则对x中各元素进行搜索，遇到符合条件的第一个子字符串的位置（gsub是替换所有符合条件的），用replacement替换该子字符串，返回替换后的结果，和x的结构相同。为了清晰地介绍例子，我们对replacement统一赋值为“”，相当于去掉搜寻出来的子字符串。例如sub("a","",c("abcd","dcba"))，将向量中的两个字符串中的a都去掉了，返回[1] "bcd" "dcb"。该例中的"a"只是一个字符，并不是正则表达式，真正的正则表达式依靠元字符进行灵活的匹配。

　　“^”匹配一个字符串的开始，比如sub("^a","",c("abcd","dcba"))，表示将开头为a的字符串中的a替换成空，在返回值中可以发现后面出现的a并没有被替换。如果要将开头的一个字符串替换，简单地写成“^ab”就行。

　　“$”匹配一个字符串的结尾，比如sub("a$","",c("abcd","dcba"))表示将以a结尾的字符串中的a替换成空。
　　
　　"."表示除了换行符以外的任一字符，比如sub("a.c","",c("abcd","sdacd"))。
　　
　　“*”表示将其前的字符进行0个或多个的匹配，比如sub("a*b","",c("aabcd","dcaaaba"))。
　　
　　“?”匹配0或1个正好在它之前的那个字符，“+”匹配1或多个正好在它之前的那个字符。
　　
　　“.*”可以匹配任意字符，比如sub("a.*e","",c("abcde","edcba"))。

　　“|”表示逻辑的或，比如sub("ab|ba","",c("abcd","dcba"))，可以替换ab或者ba。
　　
　　“^”还可以表示逻辑的补集，需要写在“[]”中，比如sub("[^ab]","",c("abcd","dcba"))，由于sub只替换搜寻到的第一个，因此这个例子中用gsub效果更好。

　　“[]”还可以用来匹配多个字符，如果不使用任何分隔符号，则搜寻这个集合，比如在sub("[ab]","",c("abcd","dcba"))中，和"a|b"效果一样。“[-]”的形式可以匹配一个范围，比如sub("[a-c]","",c("abcde","edcba"))匹配从a到c的字符，sub("[1-9]","",c("ab001","001ab"))匹配从1到9的数字。

　 默认情况下是匹配尽可能多的字符，是为贪婪匹配，比如sub("a.*b","",c("aabab","eabbe"))，默认匹配最长的a开头b结尾的字串，也就是整个字符串。
　 
　 如果要进行懒惰匹配，也就是匹配最短的字串，只需要在后面加个“?”，比如sub("a.*?b","",c("aabab","eabbe"))，就会匹配最开始找到的最短的a开头b结尾的字串。
